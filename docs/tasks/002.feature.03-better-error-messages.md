# 002.feature.03: Better Error Messages

**Status:** Pending
**Priority:** High
**Complexity:** Medium

## Objective

When element selection fails, provide actionable debugging information including similar selectors on the page, element visibility status, and page context.

## Context

"Element not found" is the most common failure mode. Currently, this error gives no insight into _why_ it failed. Was the selector wrong? Is the element hidden? Is it covered by another element? Better error messages dramatically reduce debugging time.

## Technical Details

### Implementation Location

New file: `src/errors.ts`
Updates to: `src/session.ts`, `src/cursor.ts`

### Enhanced Error Information

When a selector fails, report:

1. **Similar selectors** - Other `data-testid` values on the page
2. **Element state** - If element exists but is hidden/covered
3. **Page context** - Current URL and title

### Code: Error Helper

```typescript
// src/errors.ts
import type { Page } from 'playwright';

export interface ElementErrorContext {
  selector: string;
  url: string;
  title: string;
  similarTestIds: string[];
  elementState?: 'hidden' | 'covered' | 'not_found';
  coveredBy?: string;
}

export async function getElementErrorContext(
  page: Page,
  selector: string
): Promise<ElementErrorContext> {
  const url = page.url();
  const title = await page.title();

  // Find similar data-testid values
  const similarTestIds = await page.evaluate(sel => {
    const testIds = Array.from(document.querySelectorAll('[data-testid]'))
      .map(el => el.getAttribute('data-testid'))
      .filter((id): id is string => id !== null);

    // Extract the testid from selector if it's a testid selector
    const match = sel.match(/data-testid="([^"]+)"/);
    const targetId = match?.[1] ?? sel;

    // Find similar (simple string similarity)
    return testIds
      .filter(
        id =>
          id.includes(targetId) ||
          targetId.includes(id) ||
          id.split('-').some(part => targetId.includes(part))
      )
      .slice(0, 5);
  }, selector);

  // Check if element exists but is hidden
  const element = await page.$(selector);
  let elementState: 'hidden' | 'covered' | 'not_found' = 'not_found';
  let coveredBy: string | undefined;

  if (element) {
    const isVisible = await element.isVisible();
    if (!isVisible) {
      elementState = 'hidden';
    } else {
      // Check if covered by another element
      const box = await element.boundingBox();
      if (box) {
        const coveringElement = await page.evaluate(
          ({ x, y }) => {
            const el = document.elementFromPoint(x, y);
            if (el) {
              return el.getAttribute('data-testid') || el.tagName.toLowerCase();
            }
            return null;
          },
          { x: box.x + box.width / 2, y: box.y + box.height / 2 }
        );

        const targetTestId = await element.getAttribute('data-testid');
        if (coveringElement && coveringElement !== targetTestId) {
          elementState = 'covered';
          coveredBy = coveringElement;
        }
      }
    }
  }

  return { selector, url, title, similarTestIds, elementState, coveredBy };
}

export function formatElementError(context: ElementErrorContext): string {
  const lines = [`Element not found: ${context.selector}`];
  lines.push('');

  if (context.elementState === 'hidden') {
    lines.push('Element exists but is HIDDEN (display: none or visibility: hidden)');
  } else if (context.elementState === 'covered') {
    lines.push(`Element exists but is COVERED by: ${context.coveredBy}`);
  }

  if (context.similarTestIds.length > 0) {
    lines.push('');
    lines.push('Similar data-testid values on page:');
    context.similarTestIds.forEach(id => lines.push(`  - ${id}`));
  }

  lines.push('');
  lines.push(`Page: ${context.title}`);
  lines.push(`URL: ${context.url}`);

  return lines.join('\n');
}
```

### Integration in Session

```typescript
// In processCommand, wrap click/type/waitFor with enhanced errors
case 'click':
  try {
    await cursor.click(params.selector as string);
  } catch (err) {
    if (err instanceof Error && err.message.includes('not found')) {
      const context = await getElementErrorContext(page, params.selector as string);
      throw new Error(formatElementError(context));
    }
    throw err;
  }
  break;
```

## Acceptance Criteria

- [ ] Failed selectors show similar `data-testid` values from the page
- [ ] Hidden elements are detected and reported
- [ ] Covered elements are detected with covering element identified
- [ ] Current URL and page title included in error
- [ ] Works for click, type, and waitFor commands
- [ ] Original error preserved if not a selector issue

## Testing

```javascript
// Test similar testid suggestions
// Page has: data-testid="submit-button"
await sendCommand({ action: 'click', params: { selector: '[data-testid="submit-btn"]' } });
// Error should suggest "submit-button"

// Test hidden element detection
// Element exists but has display: none
await sendCommand({ action: 'click', params: { selector: '[data-testid="hidden-modal"]' } });
// Error should say "Element exists but is HIDDEN"

// Test covered element detection
// Button exists but cookie banner is on top
await sendCommand({ action: 'click', params: { selector: '[data-testid="buy-button"]' } });
// Error should say "Element exists but is COVERED by: cookie-banner"
```
