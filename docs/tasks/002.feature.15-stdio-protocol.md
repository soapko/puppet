# 002.feature.15: Stdio JSON Protocol

**Status:** Implemented
**Priority:** Medium
**Complexity:** Low

## Objective

Add a stdio mode that accepts JSON commands via stdin and outputs results to stdout, enabling easy subprocess integration.

## Context

File-based IPC is complex. Stdio is the standard way for processes to communicate:

- No temp files to manage
- No polling required
- Works with any language that can spawn processes
- Standard pattern (like LSP, JSON-RPC)

## Technical Details

### New File: src/stdio.ts

```typescript
import readline from 'readline';
import { startSession, sendCommand } from './session.js';
import type { SessionOptions, Command } from './types.js';

interface StdioOptions extends SessionOptions {
  // Additional options if needed
}

export async function runStdio(options: StdioOptions = {}): Promise<void> {
  // Initialize browser
  await startSession(options);

  // Signal ready
  console.log(JSON.stringify({ ready: true }));

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false,
  });

  rl.on('line', async line => {
    if (!line.trim()) return;

    try {
      const command: Command = JSON.parse(line);
      const result = await sendCommand(command);
      console.log(JSON.stringify(result));
    } catch (error) {
      console.log(
        JSON.stringify({
          success: false,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  });

  rl.on('close', async () => {
    await sendCommand({ action: 'close' });
    process.exit(0);
  });
}
```

### CLI Integration

```typescript
// src/cli.ts
import { serve } from './server.js';
import { runStdio } from './stdio.js';

const args = process.argv.slice(2);
const mode = args[0];

switch (mode) {
  case 'serve':
    // HTTP server mode
    const port = parseInt(args.find(a => a.startsWith('--port='))?.split('=')[1] || '3000');
    serve({ port, headless: !args.includes('--no-headless') });
    break;

  case 'stdio':
    // Stdio mode
    runStdio({ headless: !args.includes('--no-headless') });
    break;

  default:
    console.log('Usage: puppet <serve|stdio> [options]');
    process.exit(1);
}
```

### Protocol

**Input (stdin):** One JSON command per line

```json
{"action":"goto","params":{"url":"https://example.com"}}
{"action":"click","params":{"selector":"#btn"}}
{"action":"getText","params":{"selector":"h1"}}
{"action":"close"}
```

**Output (stdout):** One JSON result per line

```json
{"ready":true}
{"success":true,"result":{}}
{"success":true,"result":{}}
{"success":true,"result":"Example Domain"}
{"success":true,"result":{}}
```

## Usage Examples

### From Shell

```bash
# Start puppet in stdio mode
npx puppet stdio --headless

# Then send commands (one per line)
echo '{"action":"goto","params":{"url":"https://example.com"}}' | npx puppet stdio
```

### Interactive Shell Session

```bash
$ npx puppet stdio
{"ready":true}
{"action":"goto","params":{"url":"https://example.com"}}
{"success":true,"result":{}}
{"action":"getText","params":{"selector":"h1"}}
{"success":true,"result":"Example Domain"}
{"action":"close"}
{"success":true,"result":{}}
```

### From Node.js

```typescript
import { spawn } from 'child_process';

const puppet = spawn('npx', ['puppet', 'stdio', '--headless']);
const results: string[] = [];

puppet.stdout.on('data', data => {
  const lines = data.toString().split('\n').filter(Boolean);
  for (const line of lines) {
    const result = JSON.parse(line);
    results.push(result);
    console.log('Result:', result);
  }
});

function send(command: object): void {
  puppet.stdin.write(JSON.stringify(command) + '\n');
}

// Wait for ready
await new Promise(r => setTimeout(r, 2000));

send({ action: 'goto', params: { url: 'https://example.com' } });
send({ action: 'getText', params: { selector: 'h1' } });
send({ action: 'close' });
```

### From Python

```python
import subprocess
import json

# Start puppet
proc = subprocess.Popen(
    ['npx', 'puppet', 'stdio', '--headless'],
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    text=True
)

def send(command):
    proc.stdin.write(json.dumps(command) + '\n')
    proc.stdin.flush()
    return json.loads(proc.stdout.readline())

# Wait for ready
ready = json.loads(proc.stdout.readline())
print('Ready:', ready)

# Use it
send({'action': 'goto', 'params': {'url': 'https://example.com'}})
result = send({'action': 'getText', 'params': {'selector': 'h1'}})
print('Title:', result['result'])
send({'action': 'close'})
```

## Acceptance Criteria

- [ ] `runStdio()` function handles stdin/stdout communication
- [ ] Outputs `{"ready":true}` when browser is initialized
- [ ] Accepts one JSON command per line on stdin
- [ ] Outputs one JSON result per line on stdout
- [ ] Handles close gracefully
- [ ] CLI command `npx puppet stdio`
- [ ] Error results include error message
- [ ] Documentation with examples

## Testing

```bash
# Test with echo pipe
echo '{"action":"goto","params":{"url":"https://example.com"}}
{"action":"getText","params":{"selector":"h1"}}
{"action":"close"}' | npx puppet stdio --headless
```

Expected output:

```json
{"ready":true}
{"success":true,"result":{}}
{"success":true,"result":"Example Domain"}
{"success":true,"result":{}}
```

## Documentation Update

Add "Stdio Mode" section to how-to-use-puppet.md.
