# 002.feature.05: Covered Element Detection

**Status:** Pending
**Priority:** High
**Complexity:** Medium
**Depends On:** 002.feature.03 (Better Error Messages)

## Objective

Before clicking an element, detect if it's covered by another element (e.g., cookie banner, modal overlay, tooltip) and provide a clear error message.

## Context

One of the most frustrating failure modes in browser automation is when a click is "intercepted" by another element. The target element exists and is visible, but something is on top of it. Playwright sometimes reports this, but not consistently. Proactive detection provides better UX.

## Technical Details

### Implementation Location

`src/cursor.ts` - enhance the `click` method
`src/errors.ts` - add covered element detection (from task 002.feature.03)

### Approach

Before clicking, check if the element's center point would hit another element using `elementFromPoint()`.

### Code Changes to Cursor

```typescript
// src/cursor.ts

/**
 * Check if element is covered by another element
 * Returns the covering element's identifier if covered, null if clear
 */
private async checkIfCovered(selector: string): Promise<string | null> {
  return await this.page.evaluate((sel) => {
    const target = document.querySelector(sel);
    if (!target) return null;

    const rect = target.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const topElement = document.elementFromPoint(centerX, centerY);
    if (!topElement) return null;

    // Check if the top element is the target or a child of the target
    if (target.contains(topElement) || target === topElement) {
      return null; // Not covered
    }

    // Return identifier for the covering element
    return topElement.getAttribute('data-testid') ||
           topElement.id ||
           topElement.className.split(' ')[0] ||
           topElement.tagName.toLowerCase();
  }, selector);
}

/**
 * Click element with human-like approach
 * Now includes covered element detection
 */
async click(selector: string): Promise<void> {
  // First, wait for element to exist
  await this.page.waitForSelector(selector, { state: 'visible', timeout: 5000 });

  // Check if covered
  const coveredBy = await this.checkIfCovered(selector);
  if (coveredBy) {
    throw new Error(
      `Element "${selector}" is covered by another element: "${coveredBy}". ` +
      `The click would be intercepted. Dismiss the covering element first.`
    );
  }

  await this.moveTo(selector);
  if (this.options.hesitation) {
    await this.randomDelay(20, 50);
  }
  await this.page.click(selector);
}
```

### Common Covering Elements to Detect

- Cookie consent banners
- Modal overlays/backdrops
- Fixed headers that overlap content
- Tooltips
- Loading overlays
- Toast notifications

### Optional: Auto-Scroll to Avoid Fixed Headers

```typescript
/**
 * Scroll element into view, avoiding fixed headers
 */
private async scrollIntoViewSafely(selector: string): Promise<void> {
  await this.page.evaluate((sel) => {
    const element = document.querySelector(sel);
    if (!element) return;

    // Get any fixed/sticky elements at top
    const fixedElements = Array.from(document.querySelectorAll('*')).filter(el => {
      const style = getComputedStyle(el);
      return (style.position === 'fixed' || style.position === 'sticky') &&
             el.getBoundingClientRect().top < 100;
    });

    const headerHeight = fixedElements.reduce((max, el) =>
      Math.max(max, el.getBoundingClientRect().bottom), 0);

    element.scrollIntoView({ block: 'center' });

    // Adjust for fixed header
    if (headerHeight > 0) {
      window.scrollBy(0, -headerHeight - 10);
    }
  }, selector);
}
```

## Acceptance Criteria

- [ ] Click checks if element is covered before attempting click
- [ ] Clear error message identifies the covering element
- [ ] Error includes data-testid of covering element if available
- [ ] Fallback to className/tagName if no testid
- [ ] Normal clicks proceed when element is not covered
- [ ] Detection works for common overlay patterns (modals, banners)

## Testing

```javascript
// Setup: Page with cookie banner covering a button
await sendCommand({ action: 'goto', params: { url: 'https://example-with-banner.com' } });

// This should fail with clear message
const result = await sendCommand({
  action: 'click',
  params: { selector: '[data-testid="signup-button"]' },
});

// Expected error:
// Element "[data-testid="signup-button"]" is covered by another element: "cookie-banner".
// The click would be intercepted. Dismiss the covering element first.

// Dismiss banner, then click succeeds
await sendCommand({ action: 'click', params: { selector: '[data-testid="cookie-accept"]' } });
await sendCommand({ action: 'click', params: { selector: '[data-testid="signup-button"]' } });
```
